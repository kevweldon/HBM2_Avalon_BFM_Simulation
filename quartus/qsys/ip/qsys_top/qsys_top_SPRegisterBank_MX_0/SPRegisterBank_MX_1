--! @n
--! @file      RegisterBank.vhd 
--! @author    Scott E. Ritter
--! @attention PATENT:NONE
--! @date      date created: see below in the design file
--! @brief     description:  see below in the design file
--! @details
--!
--! ...
--! ...
--!
--! @copyright
--! Copyright, 2018 Raytheon BBN Technologies Corp.
-- Package and Implementation of Control, Interrupt, and Status Register
-- Bank for the PCIe interface
-- This bank of registers is memory-mapped to the PCIe IP. It is implemented
-- as an Avalon MM Slave for integration into Qsys.
-- See FPGAHostProcIntfc.docx for details
-- For this component, the Avalon writeWaitTime = 0 and readWaitTime = 0,
-- and the Pipelined Transfers Read Latency = 1
-- Scott E. Ritter 3/24/2015

-- Package declaration
library ieee;
use ieee.std_logic_1164.all;

package RegisterBank_pkg is

  -- FPGA-side register bank interfaces (write)
  type fpgaRegWrType is record
    ctlBitRESET         : std_logic;  -- W1C
  end record;
  
  constant fpgaRegWrTypeBits : natural := 1;
  
  -- FPGA-side register bank interfaces (read)
  type fpgaRegRdType is record
    ctl         : std_logic_vector(8 downto 0);
    ctlGPO      : std_logic_vector(7 downto 0);
  end record;
  
  -- Register bit indices
  constant ctlBitRESETIndx          : natural := 0;

  constant ctlBitGPIOLowIndx        : natural := 24;  -- read only
  constant ctlBitGPIOHighIndx       : natural := 31;  -- read only

  constant fpgaRegRdTypeBits : natural := 9+8; -- Sum of the above indexed values

  constant avs_readdata_bits : natural := 32;

  component RegisterBank is
  port (
    -- Avalon MM Slave Interface to Registers (Host-side access via PCIe via Qsys)
    clk        : in  std_logic                     := 'X';             -- clk
    reset_n    : in  std_logic                     := 'X';             -- reset_n
    avs_address    : in  std_logic_vector(4 downto 0)  := (others => 'X'); -- address (register bank)
    avs_write_n    : in  std_logic                     := 'X';             -- write_n
    avs_writedata  : in  std_logic_vector(31 downto 0) := (others => 'X'); -- writedata
    avs_chipselect : in  std_logic                     := 'X';             -- chipselect
    avs_read_n     : in  std_logic                     := 'X';             -- read_n
    avs_readdata   : out std_logic_vector(31 downto 0);                    -- readdata
  
    -- Register Data, Serialized records (FPGA-side access)
    coe_fpgaRegWrS : in  std_logic_vector(fpgaRegWrTypeBits-1 downto 0);
    coe_fpgaRegRdS : out std_logic_vector(fpgaRegRdTypeBits-1 downto 0);
    coe_fpgaRegBuildHash : in std_logic_vector(avs_readdata_bits-1 downto 0);
    coe_fpgaRegBuildTime : in std_logic_vector(avs_readdata_bits-1 downto 0)
  );
  end component RegisterBank;

  -- Convert fpgaRegWrType record to slv
  function fpgaRegWrType2slv(r : fpgaRegWrType)
  return std_logic_vector;--(fpgaRegWrTypeBits-1 downto 0);

  -- Convert slv to fpgaRegWrType record
  function slv2fpgaRegWrType(v : std_logic_vector(fpgaRegWrTypeBits-1 downto 0))
  return fpgaRegWrType;

  -- Convert fpgaRegRdType record to slv
  function fpgaRegRdType2slv(r : fpgaRegRdType)
  return std_logic_vector;--(fpgaRegRdTypeBits-1 downto 0);

  -- Convert slv to fpgaRegRdType record
  function slv2fpgaRegRdType(v : std_logic_vector(fpgaRegRdTypeBits-1 downto 0))
  return fpgaRegRdType;

end package RegisterBank_pkg;

package body RegisterBank_pkg is
  
  -- Convert fpgaRegWrType record to slv
  function fpgaRegWrType2slv(r : fpgaRegWrType)
  return std_logic_vector is--(fpgaRegWrTypeBits-1 downto 0) is
    variable v : std_logic_vector(fpgaRegWrTypeBits-1 downto 0);
  begin
    v(0) := r.ctlBitRESET;
    return v;
  end fpgaRegWrType2slv;

  -- Convert slv to fpgaRegWrType record
  function slv2fpgaRegWrType(v : std_logic_vector(fpgaRegWrTypeBits-1 downto 0))
  return fpgaRegWrType is
    variable r : fpgaRegWrType;
  begin
    r.ctlBitRESET         := v(0);

    return r;
  end slv2fpgaRegWrType;

  -- Convert fpgaRegRdType record to slv
  function fpgaRegRdType2slv(r : fpgaRegRdType)
  return std_logic_vector is--(fpgaRegRdTypeBits-1 downto 0) is
    variable v : std_logic_vector(fpgaRegRdTypeBits-1 downto 0);
  begin
    v := r.ctlGPO & r.ctl;
    return v;
  end fpgaRegRdType2slv;

  -- Convert slv to fpgaRegRdType record
  function slv2fpgaRegRdType(v : std_logic_vector(fpgaRegRdTypeBits-1 downto 0))
  return fpgaRegRdType is
    variable r : fpgaRegRdType;
    variable indx : natural;
  begin
    r.ctl         := v(r.ctl'high downto r.ctl'low);
    indx          := r.ctl'high + 1;
    r.ctlGPO      := v(r.ctlGPO'high+indx downto r.ctlGPO'low+indx);
    return r;
  end slv2fpgaRegRdType;
  
end package body RegisterBank_pkg;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.float_pkg.all;

library work;
use work.RegisterBank_pkg.all;

entity RegisterBank is
port (
  -- Avalon MM Slave Interface to Registers (Host-side access via PCIe via Qsys)
  clk        : in  std_logic                     := 'X';             -- clk
  reset_n    : in  std_logic                     := 'X';             -- reset_n
  avs_address    : in  std_logic_vector(4 downto 0)  := (others => 'X'); -- address (register bank)
  avs_write_n    : in  std_logic                     := 'X';             -- write_n
  avs_writedata  : in  std_logic_vector(31 downto 0) := (others => 'X'); -- writedata
  avs_chipselect : in  std_logic                     := 'X';             -- chipselect
  avs_read_n     : in  std_logic                     := 'X';             -- read_n
  avs_readdata   : out std_logic_vector(31 downto 0);                    -- readdata

  coe_fpgaRegWrS : in  std_logic_vector(fpgaRegWrTypeBits-1 downto 0);
  coe_fpgaRegRdS : out std_logic_vector(fpgaRegRdTypeBits-1 downto 0);
  coe_fpgaRegBuildHash : in std_logic_vector(avs_readdata_bits-1 downto 0);
  coe_fpgaRegBuildTime : in std_logic_vector(avs_readdata_bits-1 downto 0)
);
end entity RegisterBank;

architecture syn of RegisterBank is

  -- Register addresses
  constant ctlRegAddr         : std_logic_vector(avs_address'range) := "00000";

  constant buildIdRegAddr     : std_logic_vector(avs_address'range) := "01101";
  constant buildHashRegAddr   : std_logic_vector(avs_address'range) := "01111";
  
  -- Signals
  type regArray is record
    ctlReg          : std_logic_vector(avs_readdata'range);
  end record;
  
  signal regs, regsNext : regArray;
  signal readData, readDataNext : std_logic_vector(avs_readdata'range);
  signal coe_fpgaRegRd : fpgaRegRdType;
  signal coe_fpgaRegWr : fpgaRegWrType;

  
  -- Bit selects for RW1, RW0, RO, W1C, and RW bits (Host-side)
  constant ctlRegRW1Bits        : std_logic_vector(avs_readdata'range)  := X"0000_0021";
  constant ctlRegRWBits         : std_logic_vector(avs_readdata'range)  := not ctlRegRW1Bits;

procedure resetRegs(
  signal regs_i: out regArray
) is
begin
  regs_i            <= (others => (others => '0'));
end resetRegs;
  
begin

  -- Sequential
  process (clk, reset_n)
  begin
    if reset_n = '0' then
      -- Reset registers to default values
      readData        <= (others => '0');
      resetRegs(regs);

    elsif rising_edge(clk) then
      readData <= readDataNext;
      regs     <= regsNext;
    end if;
  end process;
  
  -- Always expose these register bits
  avs_readdata              <= readData;
  coe_fpgaRegRd.ctl         <= regs.ctlReg(coe_fpgaRegRd.ctl'range);
  coe_fpgaRegRd.ctlGPO      <= regs.ctlReg(ctlBitGPIOHighIndx downto ctlBitGPIOLowIndx);

  -- Serialize/deserialize our internal record types for Qsys compatibility
  coe_fpgaRegRdS <= fpgaRegRdType2slv(coe_fpgaRegRd);
  coe_fpgaRegWr <= slv2fpgaRegWrType(coe_fpgaRegWrS);
 
  -- Combinational (avs or fpga write)
  process(all)
  begin
  
    -- Defaults 
    regsNext <= regs;

    -- AVS gets lower write priority
    if avs_write_n = '0' then
      case avs_address is

        when ctlRegAddr =>
          -- Handle RW, RW1 bits
          regsNext.ctlReg           <= avs_writedata or (regs.ctlReg  and ctlRegRW1Bits);
                      
        when others =>
      end case;
    end if;
    
    -- FPGA gets higher write priority
    if coe_fpgaRegWr.ctlBitRESET    = '1' then regsNext.ctlReg(ctlBitRESETIndx)  <= '0'; end if; -- W1C
    
    -- Highest priority: reset
    if regs.ctlReg(ctlBitRESETIndx) = '1' then  -- reset all reg's
      resetRegs(regsNext);
    end if;
    
  end process;
      
  -- Combinational (avs_read)
  process(all)
  begin
    
    -- Default
    readDataNext <= readData;
    
    if avs_read_n = '0' then
      case avs_address is
        when ctlRegAddr =>
          readdataNext <= regs.ctlReg;

        when buildIdRegAddr => 
          readdataNext <= coe_fpgaRegBuildTime;--BID_BuildTime;
        when buildHashRegAddr => 
          readdataNext <= coe_fpgaRegBuildHash;--BID_BuildHash;
            
        when others =>
          readdataNext <= (others => '0');
      end case;
    end if;
 end process;
 end architecture syn;
